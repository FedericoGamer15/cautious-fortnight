<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enjambre de Hormigas IA & Grabador</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Lienzo principal */
        #scene {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Interfaz de usuario flotante */
        #ui-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            gap: 15px;
            align-items: center;
            border: 1px solid #eee;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        input {
            border: 1px solid #ccc;
            padding: 10px 15px;
            border-radius: 20px;
            outline: none;
            font-size: 14px;
            width: 200px;
            transition: border-color 0.3s;
        }

        input:focus {
            border-color: #333;
        }

        button {
            background: #111;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.2s, background 0.2s;
        }

        button:hover {
            background: #333;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        #btn-record {
            background: #e74c3c;
        }

        #btn-record:hover {
            background: #c0392b;
        }

        #btn-record.recording {
            animation: pulseRecord 1.5s infinite;
        }

        @keyframes pulseRecord {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }

        /* Notificaciones */
        #notification {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: #111;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 20;
        }

        #notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>

    <canvas id="scene"></canvas>

    <div id="ui-panel">
        <input type="text" id="ai-input" placeholder="Ej: Un bosque, amor, un gato..." autocomplete="off">
        <button id="btn-ai">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/></svg>
            Transformar (IA)
        </button>
        <div style="width: 1px; height: 30px; background: #ddd; margin: 0 5px;"></div>
        <button id="btn-record">
            <span style="display:inline-block; width:10px; height:10px; background:white; border-radius:50%;"></span>
            Grabar Video
        </button>
    </div>

    <div id="notification">Generando...</div>

    <script>
        // --- 1. CONFIGURACIÓN DEL RENDERIZADOR CANVAS ---
        const canvas = document.getElementById('scene');
        const ctx = canvas.getContext('2d', { alpha: false });
        let W = window.innerWidth;
        let H = window.innerHeight;
        
        // Ajustar Canvas a pantallas Retina
        function resizeCanvas() {
            W = window.innerWidth;
            H = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- 2. PRERENDERIZADO VECTORIAL DE LA HORMIGA ---
        const antCanvas = document.createElement('canvas');
        const antSize = 40;
        antCanvas.width = antSize;
        antCanvas.height = antSize;
        const actx = antCanvas.getContext('2d');
        
        function preRenderAnt() {
            actx.clearRect(0, 0, antSize, antSize);
            actx.save();
            actx.translate(antSize / 2, antSize / 2);
            actx.scale(2, 2); 
            
            actx.fillStyle = '#111';
            actx.strokeStyle = '#111';
            actx.lineWidth = 0.8;
            actx.lineCap = 'round';
            actx.lineJoin = 'round';

            // Abdomen, Torax, Cabeza
            actx.beginPath(); actx.ellipse(-4, 0, 3.5, 2.5, 0, 0, Math.PI*2); actx.fill(); actx.stroke();
            actx.beginPath(); actx.arc(1, 0, 1.8, 0, Math.PI*2); actx.fill(); actx.stroke();
            actx.beginPath(); actx.arc(5.5, 0, 2.2, 0, Math.PI*2); actx.fill(); actx.stroke();
            
            // Patas
            actx.beginPath(); actx.moveTo(0,0); actx.quadraticCurveTo(-1, -2, -3, -4.5); actx.stroke();
            actx.beginPath(); actx.moveTo(0,0); actx.quadraticCurveTo(-1, 2, -3, 4.5); actx.stroke();
            actx.beginPath(); actx.moveTo(0.5,0); actx.quadraticCurveTo(0.5, -2, 0, -4.5); actx.stroke();
            actx.beginPath(); actx.moveTo(0.5,0); actx.quadraticCurveTo(0.5, 2, 0, 4.5); actx.stroke();
            actx.beginPath(); actx.moveTo(1,0); actx.quadraticCurveTo(2, -2, 3, -4); actx.stroke();
            actx.beginPath(); actx.moveTo(1,0); actx.quadraticCurveTo(2, 2, 3, 4); actx.stroke();
            
            // Antenas
            actx.lineWidth = 0.5;
            actx.beginPath(); actx.moveTo(7,0); actx.quadraticCurveTo(8, -1, 10, -3); actx.stroke();
            actx.beginPath(); actx.moveTo(7,0); actx.quadraticCurveTo(8, 1, 10, 3); actx.stroke();
            actx.restore();
        }
        preRenderAnt();

        // --- 3. LÓGICA DEL ENJAMBRE ---
        const MAX_ANTS = 2000;
        let ants = [];
        let targets = [];
        let mode = 'face';

        function showNotification(msg, duration = 2000) {
            const notif = document.getElementById('notification');
            notif.textContent = msg;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), duration);
        }

        // Generar Forma base (Cara)
        function generateFaceTargets() {
            const offCanvas = document.createElement('canvas');
            offCanvas.width = 400; offCanvas.height = 400;
            const octx = offCanvas.getContext('2d');

            octx.strokeStyle = "black";
            octx.lineWidth = 14; octx.lineCap = "round"; octx.lineJoin = "round";
            octx.translate(200, 200);

            // Cabeza
            octx.beginPath(); octx.moveTo(0, 80); octx.bezierCurveTo(-100, 30, -110, -90, 0, -70); octx.bezierCurveTo(110, -90, 100, 30, 0, 80); octx.stroke();
            // Ojos
            octx.lineWidth = 10;
            octx.beginPath(); octx.ellipse(-55, -20, 20, 45, -Math.PI/7, 0, Math.PI*2); octx.stroke();
            octx.beginPath(); octx.ellipse(55, -20, 20, 45, Math.PI/7, 0, Math.PI*2); octx.stroke();
            // Mandíbulas
            octx.lineWidth = 12;
            octx.beginPath(); octx.moveTo(-20, 70); octx.quadraticCurveTo(-60, 150, -10, 170); octx.stroke();
            octx.beginPath(); octx.moveTo(20, 70); octx.quadraticCurveTo(60, 150, 10, 170); octx.stroke();
            // Antenas
            octx.lineWidth = 10;
            octx.beginPath(); octx.moveTo(-30, -65); octx.quadraticCurveTo(-100, -160, -150, -110); octx.stroke();
            octx.beginPath(); octx.moveTo(30, -65); octx.quadraticCurveTo(100, -160, 150, -110); octx.stroke();

            return extractPixels(octx, 400, 400);
        }

        // Generar Forma desde Texto Puro
        function generateTextTargets(textStr) {
            return new Promise((resolve) => {
                const offCanvas = document.createElement('canvas');
                const OFF_W = 800;
                const OFF_H = 400;
                offCanvas.width = OFF_W;
                offCanvas.height = OFF_H;
                const octx = offCanvas.getContext('2d');

                octx.fillStyle = 'white';
                octx.fillRect(0, 0, OFF_W, OFF_H);
                
                let fontSize = textStr.length > 10 ? 60 : 100;
                octx.font = `bold ${fontSize}px "Segoe UI", Arial, sans-serif`;
                octx.textAlign = "center";
                octx.textBaseline = "middle";
                octx.fillStyle = "black";
                
                octx.fillText(textStr, OFF_W / 2, OFF_H / 2);

                const imgData = octx.getImageData(0, 0, OFF_W, OFF_H).data;
                const pts = [];
                
                for (let y = 0; y < OFF_H; y += 3) {
                    for (let x = 0; x < OFF_W; x += 3) {
                        const r = imgData[(y * OFF_W + x) * 4];
                        if (r < 128) {
                            pts.push({ x: x - OFF_W/2, y: y - OFF_H/2 });
                        }
                    }
                }
                resolve(pts);
            });
        }

        // Generar Forma desde Imagen Generada por IA
        function generateImageTargets(imgSrc) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const offCanvas = document.createElement('canvas');
                    const OFF_W = 400; 
                    const OFF_H = 400;
                    offCanvas.width = OFF_W;
                    offCanvas.height = OFF_H;
                    const octx = offCanvas.getContext('2d');

                    octx.fillStyle = 'white';
                    octx.fillRect(0, 0, OFF_W, OFF_H);
                    
                    const scale = Math.min(OFF_W / img.width, OFF_H / img.height);
                    const dw = img.width * scale;
                    const dh = img.height * scale;
                    const dx = (OFF_W - dw) / 2;
                    const dy = (OFF_H - dh) / 2;
                    
                    octx.drawImage(img, dx, dy, dw, dh);

                    const imgData = octx.getImageData(0, 0, OFF_W, OFF_H).data;
                    const pts = [];
                    
                    for (let y = 0; y < OFF_H; y += 3) {
                        for (let x = 0; x < OFF_W; x += 3) {
                            const idx = (y * OFF_W + x) * 4;
                            const r = imgData[idx];
                            const g = imgData[idx+1];
                            const b = imgData[idx+2];
                            
                            const brightness = 0.299*r + 0.587*g + 0.114*b;
                            if (brightness < 128) {
                                pts.push({ x: x - OFF_W/2, y: y - OFF_H/2 });
                            }
                        }
                    }
                    resolve(pts);
                };
                img.onerror = () => resolve([]);
                img.src = imgSrc;
            });
        }

        function extractPixels(ctxExt, w, h) {
            const imgData = ctxExt.getImageData(0, 0, w, h).data;
            const pts = [];
            for (let y = 0; y < h; y += 3) {
                for (let x = 0; x < w; x += 3) {
                    const alpha = imgData[(y * w + x) * 4 + 3];
                    if (alpha > 100) {
                        pts.push({ x: x - w/2, y: y - h/2 });
                    }
                }
            }
            return pts;
        }

        function buildTargets(baseData) {
            baseData.sort(() => Math.random() - 0.5);
            const S = Math.min(W, H) / 500; 
            targets = baseData.map(t => ({
                x: W/2 + t.x * S,
                y: H/2 + t.y * S
            }));
        }

        async function initAnts(resetPositions = true) {
            let baseData;
            if (mode === 'face') {
                baseData = generateFaceTargets();
            } else if (mode === 'text') {
                baseData = await generateTextTargets(window.currentText);
            } else {
                baseData = await generateImageTargets(window.currentImageSrc);
            }
            
            buildTargets(baseData);

            if (targets.length === 0) {
                if (!resetPositions) ants.forEach(a => a.state = 'wandering');
                return;
            }

            if (resetPositions) {
                const numAnts = Math.min(MAX_ANTS, targets.length);
                ants = [];
                for (let i = 0; i < numAnts; i++) {
                    ants.push({
                        x: Math.random() * W,
                        y: Math.random() * H,
                        angle: Math.random() * Math.PI * 2,
                        speed: 1.5 + Math.random() * 2,
                        target: targets[i],
                        state: 'wandering',
                        swarmDelay: 2000 + Math.random() * 3000, 
                        jitterOff: Math.random() * 100
                    });
                }
            } else {
                ants.forEach((ant, i) => {
                    ant.target = targets[i % targets.length];
                    ant.state = 'swarming';
                });
                
                const targetAntsCount = Math.min(MAX_ANTS, targets.length);
                while (ants.length < targetAntsCount) {
                    ants.push({
                        x: Math.random() * W,
                        y: Math.random() * H,
                        angle: Math.random() * Math.PI * 2,
                        speed: 1.5 + Math.random() * 2,
                        target: targets[ants.length],
                        state: 'swarming',
                        swarmDelay: 0, 
                        jitterOff: Math.random() * 100
                    });
                }
            }
        }

        // --- 4. BUCLE DE ANIMACIÓN ---
        let startTime = Date.now();
        function animate() {
            const elapsed = Date.now() - startTime;
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, W, H);

            ants.forEach(ant => {
                if (ant.state === 'wandering' && elapsed > ant.swarmDelay) {
                    ant.state = 'swarming';
                }

                if (ant.state === 'wandering') {
                    ant.angle += (Math.random() - 0.5) * 0.4;
                    ant.x += Math.cos(ant.angle) * ant.speed;
                    ant.y += Math.sin(ant.angle) * ant.speed;

                    if (ant.x < 10) { ant.x = 10; ant.angle = Math.PI - ant.angle; }
                    if (ant.x > W - 10) { ant.x = W - 10; ant.angle = Math.PI - ant.angle; }
                    if (ant.y < 10) { ant.y = 10; ant.angle = -ant.angle; }
                    if (ant.y > H - 10) { ant.y = H - 10; ant.angle = -ant.angle; }

                } else if (ant.state === 'swarming') {
                    const dx = ant.target.x - ant.x;
                    const dy = ant.target.y - ant.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 3) {
                        const targetAngle = Math.atan2(dy, dx);
                        let diff = targetAngle - ant.angle;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        while (diff < -Math.PI) diff += Math.PI * 2;

                        ant.angle += diff * 0.1;
                        const currentSpeed = Math.min(ant.speed + 0.5, 6.0);
                        ant.x += Math.cos(ant.angle) * currentSpeed;
                        ant.y += Math.sin(ant.angle) * currentSpeed;
                    } else {
                        ant.state = 'settled';
                    }
                } else if (ant.state === 'settled') {
                    ant.angle += (Math.random() - 0.5) * 0.2;
                    ant.x += Math.cos(ant.angle) * 0.4;
                    ant.y += Math.sin(ant.angle) * 0.4;
                    ant.x += (ant.target.x - ant.x) * 0.1;
                    ant.y += (ant.target.y - ant.y) * 0.1;
                }

                ctx.save();
                ctx.translate(ant.x, ant.y);
                ctx.rotate(ant.angle);
                const scale = 0.5;
                ctx.drawImage(antCanvas, - (antSize/2)*scale, - (antSize/2)*scale, antSize*scale, antSize*scale);
                ctx.restore();
            });

            requestAnimationFrame(animate);
        }

        initAnts(true);
        animate();

        // --- 5. GRABACIÓN DE VIDEO NATIVA ---
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        const btnRecord = document.getElementById('btn-record');

        let checkSettledInterval;
        let maxFallbackTimeout;
        let stopRecordingTimeout;

        btnRecord.addEventListener('click', () => {
            if (isRecording) return; 
            
            startTime = Date.now();
            ants.forEach(a => {
                a.state = 'wandering';
                a.x = Math.random() * W;
                a.y = Math.random() * H;
            });

            const stream = canvas.captureStream(60);
            
            const options = { 
                mimeType: 'video/webm; codecs=vp9',
                videoBitsPerSecond: 15000000 
            };
            
            try {
                mediaRecorder = new MediaRecorder(stream, options);
            } catch (e) {
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm', videoBitsPerSecond: 15000000 });
            }
            
            recordedChunks = [];

            mediaRecorder.ondataavailable = e => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                clearInterval(checkSettledInterval);
                clearTimeout(maxFallbackTimeout);
                clearTimeout(stopRecordingTimeout);

                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'enjambre-hormigas.webm';
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100);
                
                btnRecord.innerHTML = '<span style="display:inline-block; width:10px; height:10px; background:white; border-radius:50%;"></span> Grabar Video';
                btnRecord.classList.remove('recording');
                showNotification('¡Video guardado exitosamente!', 3000);
                isRecording = false;
            };

            mediaRecorder.start();
            isRecording = true;
            btnRecord.classList.add('recording');
            btnRecord.innerHTML = 'Grabando... (Formando)';
            showNotification('Grabación iniciada...');

            checkSettledInterval = setInterval(() => {
                const settledCount = ants.filter(a => a.state === 'settled').length;
                if (settledCount > ants.length * 0.95) {
                    clearInterval(checkSettledInterval);
                    btnRecord.innerHTML = 'Grabando... (Últimos 10s)';
                    showNotification('Figura formada. Grabando últimos 10s...');
                    
                    stopRecordingTimeout = setTimeout(() => {
                        if (mediaRecorder && mediaRecorder.state === "recording") {
                            mediaRecorder.stop();
                        }
                    }, 10000);
                }
            }, 500);

            maxFallbackTimeout = setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === "recording") {
                    mediaRecorder.stop();
                }
            }, 40000);
        });

        // --- 6. INTEGRACIÓN LLM HUGGING FACE VÍA VERCEL SERVERLESS ---
        const btnAi = document.getElementById('btn-ai');
        const inputAi = document.getElementById('ai-input');

        async function fetchGeneratedImage(promptText, retries = 3) {
            // Llamamos a nuestro propio backend seguro en lugar de a la API externa directamente
            const url = `/api/generate`; 
            const payload = { prompt: promptText };

            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) throw new Error("Error en el servidor Vercel");
                    
                    const data = await response.json();
                    
                    if (data.imageUrl) {
                        return data.imageUrl; // Devuelve el base64 de la imagen
                    }
                    throw new Error("Respuesta inválida del servidor");
                } catch (err) {
                    if (i === retries - 1) throw err;
                    await new Promise(res => setTimeout(res, Math.pow(2, i) * 1000));
                }
            }
        }

        btnAi.addEventListener('click', async () => {
            const query = inputAi.value.trim();
            if(!query) {
                mode = 'face';
                await initAnts(false);
                startTime = Date.now();
                showNotification("Regresando a la forma original");
                return;
            }

            const lowerQuery = query.toLowerCase();
            const isText = lowerQuery.startsWith('palabra:') || lowerQuery.startsWith('texto:');
            
            if (isText) {
                const textToRender = query.substring(query.indexOf(':') + 1).trim().replace(/^["']|["']$/g, '');
                
                mode = 'text';
                window.currentText = textToRender;
                await initAnts(false);
                startTime = Date.now();
                showNotification(`Escribiendo con hormigas...`, 3000);
                return; 
            }

            btnAi.disabled = true;
            btnAi.innerHTML = 'Dibujando...';
            showNotification("IA Generando silueta...");

            try {
                // Ahora llama a la nueva función que conecta con Vercel
                const imageUrl = await fetchGeneratedImage(query);
                window.currentImageSrc = imageUrl; 
                mode = 'image';
                await initAnts(false); 
                startTime = Date.now(); 
                showNotification(`¡Silueta generada! Formando...`, 4000);
            } catch(e) {
                console.error(e);
                showNotification("Error conectando con la IA", 3000);
            } finally {
                btnAi.disabled = false;
                btnAi.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/></svg> Transformar (IA)`;
            }
        });

        inputAi.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') btnAi.click();
        });

    </script>
</body>
</html>