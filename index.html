<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enjambre de Hormigas IA & Grabador</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Lienzo principal */
        #scene {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Interfaz de usuario flotante */
        #ui-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            gap: 15px;
            align-items: center;
            border: 1px solid #eee;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        input {
            border: 1px solid #ccc;
            padding: 10px 15px;
            border-radius: 20px;
            outline: none;
            font-size: 14px;
            width: 200px;
            transition: border-color 0.3s;
        }

        input:focus {
            border-color: #333;
        }

        button {
            background: #111;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.2s, background 0.2s;
        }

        button:hover {
            background: #333;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        #btn-record {
            background: #e74c3c;
        }

        #btn-record:hover {
            background: #c0392b;
        }

        #btn-record.recording {
            animation: pulseRecord 1.5s infinite;
        }

        @keyframes pulseRecord {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }

        /* Notificaciones */
        #notification {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: #111;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 20;
        }

        #notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>

    <canvas id="scene"></canvas>

    <div id="ui-panel">
        <input type="text" id="ai-input" placeholder="Ej: Un bosque, amor, un gato..." autocomplete="off">
        <button id="btn-ai">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/></svg>
            Transformar (IA)
        </button>
        <div style="width: 1px; height: 30px; background: #ddd; margin: 0 5px;"></div>
        <button id="btn-record">
            <span style="display:inline-block; width:10px; height:10px; background:white; border-radius:50%;"></span>
            Grabar Video
        </button>
    </div>

    <div id="notification">Generando...</div>

    <script>
        // --- 1. CONFIGURACIÓN DEL RENDERIZADOR CANVAS ---
        const canvas = document.getElementById('scene');
        const ctx = canvas.getContext('2d', { alpha: false });
        let W = window.innerWidth;
        let H = window.innerHeight;
        
        function resizeCanvas() {
            W = window.innerWidth;
            H = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- 2. PRERENDERIZADO VECTORIAL DE LA HORMIGA ---
        const antCanvas = document.createElement('canvas');
        const antSize = 30; // Un poco más grande para mejor detalle en el dibujo
        antCanvas.width = antSize;
        antCanvas.height = antSize;
        const actx = antCanvas.getContext('2d');
        
        function preRenderAnt() {
            actx.clearRect(0, 0, antSize, antSize);
            actx.save();
            actx.translate(antSize / 2, antSize / 2);
            actx.scale(1.5, 1.5); 
            
            actx.fillStyle = '#111';
            actx.strokeStyle = '#111';
            actx.lineWidth = 0.8;
            actx.lineCap = 'round';
            actx.lineJoin = 'round';

            // Cuerpo
            actx.beginPath(); actx.ellipse(-4, 0, 3.5, 2.5, 0, 0, Math.PI*2); actx.fill(); actx.stroke();
            actx.beginPath(); actx.arc(1, 0, 1.8, 0, Math.PI*2); actx.fill(); actx.stroke();
            actx.beginPath(); actx.arc(5.5, 0, 2.2, 0, Math.PI*2); actx.fill(); actx.stroke();
            
            // Patas
            actx.beginPath(); actx.moveTo(0,0); actx.quadraticCurveTo(-1, -2, -3, -4.5); actx.stroke();
            actx.beginPath(); actx.moveTo(0,0); actx.quadraticCurveTo(-1, 2, -3, 4.5); actx.stroke();
            actx.beginPath(); actx.moveTo(0.5,0); actx.quadraticCurveTo(0.5, -2, 0, -4.5); actx.stroke();
            actx.beginPath(); actx.moveTo(0.5,0); actx.quadraticCurveTo(0.5, 2, 0, 4.5); actx.stroke();
            actx.beginPath(); actx.moveTo(1,0); actx.quadraticCurveTo(2, -2, 3, -4); actx.stroke();
            actx.beginPath(); actx.moveTo(1,0); actx.quadraticCurveTo(2, 2, 3, 4); actx.stroke();
            
            // Antenas
            actx.lineWidth = 0.5;
            actx.beginPath(); actx.moveTo(7,0); actx.quadraticCurveTo(8, -1, 10, -3); actx.stroke();
            actx.beginPath(); actx.moveTo(7,0); actx.quadraticCurveTo(8, 1, 10, 3); actx.stroke();
            actx.restore();
        }
        preRenderAnt();

        // --- 3. LÓGICA DEL ENJAMBRE ---
        const MAX_ANTS = 5000; // ¡Aumentamos drásticamente el número para más detalle!
        let ants = [];
        let targets = [];
        let mode = 'face';

        function showNotification(msg, duration = 2000) {
            const notif = document.getElementById('notification');
            notif.textContent = msg;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), duration);
        }

        // Generar Cara de Hormiga original
        function generateFaceTargets() {
            const offCanvas = document.createElement('canvas');
            offCanvas.width = 400; offCanvas.height = 400;
            const octx = offCanvas.getContext('2d');
            octx.strokeStyle = "black";
            octx.lineWidth = 14; octx.lineCap = "round"; octx.lineJoin = "round";
            octx.translate(200, 200);
            octx.beginPath(); octx.moveTo(0, 80); octx.bezierCurveTo(-100, 30, -110, -90, 0, -70); octx.bezierCurveTo(110, -90, 100, 30, 0, 80); octx.stroke();
            octx.lineWidth = 10;
            octx.beginPath(); octx.ellipse(-55, -20, 20, 45, -Math.PI/7, 0, Math.PI*2); octx.stroke();
            octx.beginPath(); octx.ellipse(55, -20, 20, 45, Math.PI/7, 0, Math.PI*2); octx.stroke();
            octx.lineWidth = 12;
            octx.beginPath(); octx.moveTo(-20, 70); octx.quadraticCurveTo(-60, 150, -10, 170); octx.stroke();
            octx.beginPath(); octx.moveTo(20, 70); octx.quadraticCurveTo(60, 150, 10, 170); octx.stroke();
            octx.lineWidth = 10;
            octx.beginPath(); octx.moveTo(-30, -65); octx.quadraticCurveTo(-100, -160, -150, -110); octx.stroke();
            octx.beginPath(); octx.moveTo(30, -65); octx.quadraticCurveTo(100, -160, 150, -110); octx.stroke();
            return extractPixels(octx, 400, 400, 2); // Resolución más alta
        }

        function generateTextTargets(textStr) {
            return new Promise((resolve) => {
                const offCanvas = document.createElement('canvas');
                const OFF_W = 800; const OFF_H = 400;
                offCanvas.width = OFF_W; offCanvas.height = OFF_H;
                const octx = offCanvas.getContext('2d');
                octx.fillStyle = 'white'; octx.fillRect(0, 0, OFF_W, OFF_H);
                let fontSize = textStr.length > 8 ? 70 : 120;
                octx.font = `900 ${fontSize}px "Segoe UI", Arial, sans-serif`;
                octx.textAlign = "center"; octx.textBaseline = "middle";
                octx.fillStyle = "black";
                octx.fillText(textStr, OFF_W / 2, OFF_H / 2);
                const imgData = octx.getImageData(0, 0, OFF_W, OFF_H).data;
                const pts = [];
                const step = 4; // Paso intermedio para texto nítido
                for (let y = 0; y < OFF_H; y += step) {
                    for (let x = 0; x < OFF_W; x += step) {
                        if (imgData[(y * OFF_W + x) * 4] < 128) {
                            pts.push({ x: x - OFF_W/2, y: y - OFF_H/2 });
                        }
                    }
                }
                resolve(pts);
            });
        }

        function generateImageTargets(imgSrc) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const offCanvas = document.createElement('canvas');
                    const OFF_W = 400; const OFF_H = 400;
                    offCanvas.width = OFF_W; offCanvas.height = OFF_H;
                    const octx = offCanvas.getContext('2d');
                    octx.fillStyle = 'white'; octx.fillRect(0, 0, OFF_W, OFF_H);
                    const scale = Math.min(OFF_W / img.width, OFF_H / img.height);
                    const dw = img.width * scale; const dh = img.height * scale;
                    octx.drawImage(img, (OFF_W - dw) / 2, (OFF_H - dh) / 2, dw, dh);
                    const imgData = octx.getImageData(0, 0, OFF_W, OFF_H).data;
                    const pts = [];
                    const step = 2; // ¡Súper resolución para caras y siluetas!
                    for (let y = 0; y < OFF_H; y += step) {
                        for (let x = 0; x < OFF_W; x += step) {
                            const idx = (y * OFF_W + x) * 4;
                            const brightness = 0.299*imgData[idx] + 0.587*imgData[idx+1] + 0.114*imgData[idx+2];
                            if (brightness < 160) { // Umbral un poco más alto para no perder líneas finas
                                pts.push({ x: x - OFF_W/2, y: y - OFF_H/2 });
                            }
                        }
                    }
                    resolve(pts);
                };
                img.src = imgSrc;
            });
        }

        function extractPixels(ctxExt, w, h, step = 3) {
            const imgData = ctxExt.getImageData(0, 0, w, h).data;
            const pts = [];
            for (let y = 0; y < h; y += step) {
                for (let x = 0; x < w; x += step) {
                    if (imgData[(y * w + x) * 4 + 3] > 100) {
                        pts.push({ x: x - w/2, y: y - h/2 });
                    }
                }
            }
            return pts;
        }

        function buildTargets(baseData) {
            baseData.sort(() => Math.random() - 0.5);
            const S = Math.min(W, H) / 550; // Ligeramente más grande
            targets = baseData.map(t => ({
                x: W/2 + t.x * S,
                y: H/2 + t.y * S
            }));
        }

        async function initAnts(resetPositions = true) {
            let baseData;
            if (mode === 'face') baseData = generateFaceTargets();
            else if (mode === 'text') baseData = await generateTextTargets(window.currentText);
            else baseData = await generateImageTargets(window.currentImageSrc);
            
            buildTargets(baseData);
            if (targets.length === 0) return;

            if (resetPositions) {
                ants = [];
                // Creamos un enjambre denso
                const count = Math.min(MAX_ANTS, targets.length + 200);
                for (let i = 0; i < count; i++) {
                    ants.push({
                        x: Math.random() * W, y: Math.random() * H,
                        angle: Math.random() * Math.PI * 2,
                        speed: 1.5 + Math.random() * 2,
                        target: targets[i % targets.length],
                        state: 'wandering',
                        swarmDelay: 1500 + Math.random() * 2500, 
                        isRebel: Math.random() < 0.04 // 4% de hormigas correteando
                    });
                }
            } else {
                // Re-asignar sin perder la vida
                ants.forEach((ant, i) => {
                    ant.target = targets[i % targets.length];
                    if (!ant.isRebel) ant.state = 'swarming';
                });
                // Si faltan hormigas para la nueva figura, añadir más
                while (ants.length < Math.min(MAX_ANTS, targets.length + 200)) {
                    ants.push({
                        x: Math.random() * W, y: Math.random() * H,
                        angle: Math.random() * Math.PI * 2,
                        speed: 1.5 + Math.random() * 2,
                        target: targets[ants.length % targets.length],
                        state: 'swarming', swarmDelay: 0, isRebel: Math.random() < 0.04
                    });
                }
            }
        }

        // --- 4. BUCLE DE ANIMACIÓN ---
        let startTime = Date.now();
        function animate() {
            const elapsed = Date.now() - startTime;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, W, H);

            ants.forEach(ant => {
                if (ant.state === 'wandering' && elapsed > ant.swarmDelay && !ant.isRebel) {
                    ant.state = 'swarming';
                }

                if (ant.state === 'wandering') {
                    ant.angle += (Math.random() - 0.5) * 0.4;
                    ant.x += Math.cos(ant.angle) * ant.speed;
                    ant.y += Math.sin(ant.angle) * ant.speed;
                    if (ant.x < 10 || ant.x > W - 10) ant.angle = Math.PI - ant.angle;
                    if (ant.y < 10 || ant.y > H - 10) ant.angle = -ant.angle;
                } else if (ant.state === 'swarming') {
                    const dx = ant.target.x - ant.x;
                    const dy = ant.target.y - ant.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 2) {
                        const targetAngle = Math.atan2(dy, dx);
                        let diff = targetAngle - ant.angle;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        ant.angle += diff * 0.12;
                        ant.x += Math.cos(ant.angle) * (ant.speed + 2);
                        ant.y += Math.sin(ant.angle) * (ant.speed + 2);
                    } else {
                        ant.state = 'settled';
                    }
                } else if (ant.state === 'settled') {
                    if (ant.isRebel) ant.state = 'wandering';
                    ant.angle += (Math.random() - 0.5) * 0.3;
                    ant.x += Math.cos(ant.angle) * 0.4 + (ant.target.x - ant.x) * 0.2;
                    ant.y += Math.sin(ant.angle) * 0.4 + (ant.target.y - ant.y) * 0.2;
                }

                ctx.save();
                ctx.translate(ant.x, ant.y);
                ctx.rotate(ant.angle);
                // Tamaño reducido (0.4) para permitir ver detalles finos en figuras complejas
                const scale = 0.4; 
                ctx.drawImage(antCanvas, - (antSize/2)*scale, - (antSize/2)*scale, antSize*scale, antSize*scale);
                ctx.restore();
            });

            requestAnimationFrame(animate);
        }

        initAnts(true);
        animate();

        // --- 5. GRABACIÓN DE VIDEO NATIVA ---
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        const btnRecord = document.getElementById('btn-record');

        btnRecord.addEventListener('click', () => {
            if (isRecording) return; 
            startTime = Date.now();
            ants.forEach(a => { a.state = 'wandering'; a.x = Math.random() * W; a.y = Math.random() * H; });
            const stream = canvas.captureStream(60);
            const options = { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: 15000000 };
            try { mediaRecorder = new MediaRecorder(stream, options); } catch (e) { mediaRecorder = new MediaRecorder(stream, { videoBitsPerSecond: 15000000 }); }
            recordedChunks = [];
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.style.display = 'none'; a.href = url; a.download = 'enjambre-hormigas.webm';
                document.body.appendChild(a); a.click();
                btnRecord.innerHTML = '<span style="display:inline-block; width:10px; height:10px; background:white; border-radius:50%;"></span> Grabar Video';
                btnRecord.classList.remove('recording');
                showNotification('¡Video guardado exitosamente!', 3000);
                isRecording = false;
            };
            mediaRecorder.start();
            isRecording = true;
            btnRecord.classList.add('recording');
            btnRecord.innerHTML = 'Grabando...';
            showNotification('Grabación iniciada...');
            setInterval(() => {
                const settled = ants.filter(a => a.state === 'settled').length;
                if (settled > ants.length * 0.95 && isRecording && mediaRecorder.state === "recording") {
                    setTimeout(() => mediaRecorder.stop(), 10000);
                }
            }, 1000);
        });

        // --- 6. IA INTEGRACIÓN ---
        const btnAi = document.getElementById('btn-ai');
        const inputAi = document.getElementById('ai-input');

        async function fetchGeneratedImage(promptText) {
            const url = `/api/generate`; 
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: promptText })
            });
            if (!response.ok) throw new Error("Error en el servidor");
            const data = await response.json();
            return data.imageUrl;
        }

        btnAi.addEventListener('click', async () => {
            const query = inputAi.value.trim();
            if(!query) { mode = 'face'; await initAnts(false); startTime = Date.now(); return; }
            const isText = query.toLowerCase().startsWith('palabra:') || query.toLowerCase().startsWith('texto:');
            if (isText) {
                window.currentText = query.substring(query.indexOf(':') + 1).trim().replace(/^["']|["']$/g, '');
                mode = 'text'; await initAnts(false); startTime = Date.now(); return; 
            }
            btnAi.disabled = true; btnAi.innerHTML = 'Dibujando...';
            showNotification("IA Generando silueta...");
            try {
                window.currentImageSrc = await fetchGeneratedImage(query);
                mode = 'image'; await initAnts(false); startTime = Date.now();
                showNotification(`¡Figura generada! Formando...`, 4000);
            } catch(e) { showNotification("Error con la IA", 3000); } finally {
                btnAi.disabled = false; btnAi.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/></svg> Transformar (IA)`;
            }
        });
        inputAi.addEventListener('keypress', (e) => { if (e.key === 'Enter') btnAi.click(); });
    </script>
</body>
</html>
